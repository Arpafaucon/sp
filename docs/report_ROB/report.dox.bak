/**
 * \file report.dox
 * \brief Rapport du projet ROB 314
 * \author Grégoire Roussel
 */

/**


\page report Rapport de projet ROB314 

Grégoire Roussel

11 mars 2019

\section Introduction

\subsection objectif Objectif

L'objectif du projet est de construire et valider expérimentalement un système de surveillance d'une zone impliquant plusieurs drones coordonnés. Les besoins identifiés pour le système sont :
- optimiser les rondes des différents agents pour survoler chaque endroit le plus régulièrement possible
- planifier et faire exécuter des trajectoires sans collisions
- détecter des situations de défaillance des drones actifs: batterie, réponse anormale...
- garantir la robustesse du système en remplaçant à chaud les drones défaillants
- fournir un compte rendu visuel de la situation actuelle

L'accent a été mis, non pas sur le développement d'un bloc scientifiquement innovant, mais sur la conception d'un système fonctionnel dans son ensemble, et qui me permette d'approfondir des problèmes récurrents d'un projet informatique complexe:
- paramètrage
- interfaces et communications multi-processus 
- utilisation de code extérieur
- réutilisation de code mis en commun

Et des thématiques fréquentes de la programmation robotique :
- localisation
- simulation
- commande et contrôle
- coordination de plusieurs agents
- visualisations pour permettre la compréhension du système

\subsection techno Matériel et technologies

Dans l'expérience, les drones de surveillances sont des Crazyflie (bitcraze, https://www.bitcraze.io/crazyflie-2/). Ce sont des petits quadri-coptères très légers (environ 40g) controllables via radio par un ordinateur central.

Cette base centrale exécute le méta-OS ROS: http://www.ros.org/ . Ce méta-OS, couramment utilisée lors du prototypage de robots facilite l'interaction entre processus et la conception de blocs fonctionnels modulaires et réutilisables. Elle fournit par ailleurs des outils de développement, de diagnostics et de visualisation qui simplifient la conception d'un système robotique. Dans ce projet, les outils **RVIZ** (outil de visualisation générique) et **Gazebo** (moteur de simulation) sont beaucoup utilisés.


\imageSize{crazyflie20.jpg,width:10cm;,"drone Crazyflie 2.0"}

\section structureGenerale Structure Générale

\subsection outilsExt Outils externes

\subsubsection crazyflie Crazyflie

Outre leur disponibilité au laboratoire, le choix des Crazyflie se justifie par leur faible coût et leur grande robustesse aux chocs. Par ailleurs, la communauté ROS met à disposition des drivers et un programme de simulation aux **interfaces similaires**. Ainsi, le projet peut indépendamment contrôler des drones simulés ou réels, ou même une combinaison des deux.

La salle d'expérimentation cyber-physique du LIX contient une dizaine de drones Crazyflie, et un dispositif de localisation externe: le **Loco Positioning System**. Chaque Crazyflie se positionne dans l'espace en comparant les délais de transmissions avec de multiples balises radio, en quelque sorte comme un GPS d'intérieur. La précision de ce système est de l'ordre de la dizaine de centimètres, avec une incertitude principalement sur l'altitude.

\image html tdoa.png "Exemple de résolution de la position en 2D avec 3 balises"

\subsection software Architecture Externe

Le projet s'apuie sur deux *stacks* (ensembles de packages ROS) externes:


\subsubsection crazyflie_ros
[Wolfgang Hoenig - `whoenig`], https://github.com/whoenig/crazyflie_ros. Licence M.I.T.

driver entre ROS et le protocole de communication crazyflie (CRTP: Crazyflie Real-Time Protocol). Fournit un serveur de commande auquel on peut connecter des crazyflies (réels ou virtuels). Pour chaque crazyflie sont rendus disponibles des services pour le contrôler, et les logs sous la formes de *topics*.

Il fournit par ailleurs un modèle visuel 3D de Crazyflie pour Gazebo.

\subsubsection sim_cf

[Franck Djeumou - `wuwushrek`], https://github.com/wuwushrek/sim_cf. 

Module de simulation pour Crazyflie. Reçoit les commandes CRTP comme un drone réel, et simule la réponse logicielle, puis dynamique, par Gazebo. Le programme peut fonctionner en mode **SITL** (*Software in the Loop* : le logiciel du Crazyflie est simulé intégralement) ou **HITL** (*Hardware in the Loop*: un crazyflie réel est impliqué, mais ses réponses commandent des moteurs virtuels).


J'ai travaillé à la migration de ce package sous ROS Melodic (il y a une mise à jour majeure de l'API de Gazebo entre Kinetic et Melodic - il fallait reprendre une partie du code des plugins Gazebo). A cours de l'année, j'ai aussi amélioré quelques fonctionnalités annexes (scripts de lancement et de configuration).


\subsubsection agencement Architecture

Le diagramme ci-dessous illustre les relations et échanges entre les différents outils externes impliqués et le module `sp` du projet:
- en **bleu** : lors d'une simulation
- en **rouge** : lors d'une expérience réelle


\imageSize{outils.png,width:15cm;, "Architecture des packages"}

\subsection internArch Architecture interne

\subsubsection boat La métaphore du bateau
Une courte (et imparfaite) analogie avec le fonctionnement d'un bateau (ancien) permet d'introduire les *nodes* impliquées dans le fonctionnement de \p sp.
- l'**admiral** donne l'objectif à atteindre: il donne la stratégie générale sous la forme de zones à atteindre, peu importe par quel navire
- le **capitaine** est chargé de réaliser cet ordre : il assigne à chaque vaisseau/drone une position à atteindre, et un itinéraire pour y parvenir
- le **second**  (mate) contrôle l'exécution des ordres donnés, et évite les éventuelles collisions entre navires.
- la **vigie** (lookout) fournit les positions des navires en manoeuvre



\imageSize{boat.png,width:10cm;,rôle des *nodes*}

\subsubsection active_connected Drones actifs et drones connectés

Pour faciliter le travail de la planification, on introduit l'abstraction de **drone actif**, qui représente un drone en état d'accomplir des missions de surveillance, sans 
\imageSize{activeVsConnected.png,width:10cm;,"Drones actifs / connectés"}

\section Description individuelle des nodes

\subsection sp_admiral Admiral

Le *node* `sp_admiral` est responsable de gérer et optimiser la surveillance à long terme de la zone. Pour ce faire, il selectionne 
*/